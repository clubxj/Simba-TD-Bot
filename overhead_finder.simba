{$IFNDEF WASPLIB_OSRS} {$I WaspLib/osrs.simba} {$ENDIF}

type
  ERSOverhead = (
    MAGIC, RANGED, MELEE, RETRIBUTION, REDEMPTION, SMITE,
    MAGIC_AND_RANGED, MAGIC_AND_MELEE, RANGED_AND_MELEE, ALL,
    DAMPEN_MELEE
  );

  TRSOverhead = record
    Position: TPoint;
    Overhead: ERSOverhead;
  end;

  TRSOverheadArray = array of TRSOverhead;

  TRSOverheadFinder = record
    Images: array[ERSOverhead] of TImage;
  end;

procedure TRSOverheadFinder.Free();
var
  overhead: ERSOverhead;
begin
  for overhead := Low(ERSOverhead) to High(ERSOverhead) do
  begin
    Self.Images[overhead].Free;
    Self.Images[overhead] := nil;
  end;
end;

procedure TRSOverheadFinder.Setup();
var
  overhead: ERSOverhead;
  path: String;
begin
  for overhead := Low(ERSOverhead) to High(ERSOverhead) do
  begin
    path := {$MACRO DIR} + 'overheads\' + ToStr(overhead).ToLower.After('ersoverhead.') + '.png';
    Self.Images[overhead] := TImage.Create(path);
    Self.Images[overhead].FreeOnTerminate := True;
  end;
end;

function TRSOverheadFinder.Find(overheads: set of ERSOverhead; maxToFind: Integer = 5): TRSOverheadArray;
var
  overhead: ERSOverhead;
  bounds: TBox;
  searchingBounds: TBoxArray;
  image: TImage;
  matrix: TSingleMatrix;
  d: double;
begin
  d := PerformanceTime;

  searchingBounds := Target.FindColor($74B0C7, 2.844, EColorSpace.RGB, [0.681, 1.299, 1.021], MainScreen.Bounds).Cluster(5).BoundsArray;
  if searchingBounds.Length = 0 then
    Exit;

  for overhead in overheads do
  begin
    for bounds in searchingBounds do
    begin
      if (bounds.Width < Self.Images[overhead].Width) or (bounds.Height < Self.Images[overhead].Height) then
        Continue;

      image := Target.GetImage(bounds);
      try
        matrix := MatchTemplate(image, Self.Images[overhead], ETMFormula.TM_CCOEFF_NORMED);
      finally
        image.Free;
      end;

      with matrix.ArgMax do
      begin
        if matrix[y,x] < 0.99 then
          Break;
        Result += [Point(X,Y) + bounds.TopLeft + MainScreen.Bounds.TopLeft + Point(6,7), overhead];
        if Result.Length = maxToFind then
          Exit;
      end;
    end;
  end;
end;

var
  OverheadFinder: TRSOverheadFinder;
