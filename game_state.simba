{$IFNDEF WASPLIB_OSRS} {$I WaspLib/osrs.simba} {$ENDIF}
{$include_once task_manager.simba}
{$INCLUDE_ONCE overhead_finder.simba}
{$INCLUDE_ONCE combat_types.simba}
{$INCLUDE_ONCE tbox.simba}
{$INCLUDE_ONCE inventory.simba}

const
  HITSPLAT_BUFFER_SIZE = 50;
  HITSPLAT_EXPIRE_MS = 1000;
  PROJECTILE_BUFFER_SIZE = 20;
  PROJECTILE_SAMPLE_EXPIRE_MS = 2000;

type
  THitSplatSample = record
    HitSplat: TRSHitSplat;
    TimeStamp: UInt64;
  end;

  TProjectileSample = record
    Style: ERSCombatStyle;
    TimeStamp: UInt64;
  end;

  TTDBotGameState = record
    TaskManager: TReschedulingTaskManager;

    pLock: TLock;
    pPosition: TPoint;
    pActivePrayers: TRSPrayerSet;
    pInventoryItems: TRSDiscoveredInventory;
    pHitSplatBuffer: array[0..HITSPLAT_BUFFER_SIZE - 1] of THitSplatSample;
    pHitSplatBufferIndex: Integer;
    pDivineDoses: Integer;
    pLastDivineConsume: Integer;

    tdLock: TLock;
    tdProtectedStyle: ERSCombatStyle;
    tdCombatStyle: ERSCombatStyle;
    tdMainScreenPoints: TPointArray;
    tdPosition: TPoint;
    tdHealth: Integer;
    tdIsCastingSnare: Boolean;
    tdProjectileBuffer: array[0..PROJECTILE_BUFFER_SIZE - 1] of TProjectileSample;
    tdProjectileBufferIndex: Integer;
  end;

procedure TTDBotGameState.SetPlayerPosition(position: TPoint);
begin
  Self.pLock.Enter;
  Self.pPosition := position;
  Self.pLock.Leave;
end;

function TTDBotGameState.GetPlayerPosition(): TPoint;
begin
  Self.pLock.Enter;
  Result := Self.pPosition;
  Self.pLock.Leave;
end;

procedure TTDBotGameState.ReadPlayerPosition();
begin
  //if RSClient.IsLoggedIn then
   Self.SetPlayerPosition(Map.Position);
end;

procedure TTDBotGameState.SetInventoryItems(items: TRSDiscoveredInventory);
begin
  Self.pLock.Enter;
  Self.pInventoryItems := items.Copy;
  Self.pLock.Leave;
end;

function TTDBotGameState.GetInventoryItems(): TRSDiscoveredInventory;
begin
  Self.pLock.Enter;
  Result := Self.pInventoryItems.Copy;
  Self.pLock.Leave;
end;

procedure TTDBotGameState.SetPlayerActivePrayers(prayers: TRSPrayerSet);
begin
  Self.pLock.Enter;
  Self.pActivePrayers := prayers;
  Self.pLock.Leave;
end;

function TTDBotGameState.GetPlayerActivePrayers(): TRSPrayerSet;
begin
  Self.pLock.Enter;
  Result := Self.pActivePrayers;
  Self.pLock.Leave;
end;

procedure TTDBotGameState.ReadInventoryTab();
begin
  if ChooseOption.IsOpen and ChooseOption.Bounds.Intersects(GameTab.Bounds) then
    Exit;

  Self.SetInventoryItems(Inventory.Items.DiscoverAllEx);
end;

procedure TTDBotGameState.ReadPrayerTab();
var
  b: TBox;
begin
  ////triple ensure that the prayer tab is open to prevent false results.
  //if Prayer.IsOpen and Prayer.Find(ERSPrayer.THICK_SKIN, b) and Prayer.Find(ERSPrayer.PROTECT_FROM_MELEE, b) then
  //  Self.SetPlayerActivePrayers(Prayer.GetActivePrayers);
end;

procedure TTDBotGameState.ReadGameTabs();
begin
  case GameTabs.GetCurrent of
    ERSGameTab.INVENTORY: Self.ReadInventoryTab;
    ERSGameTab.PRAYER: Self.ReadPrayerTab;
  end;
  Sleep(50);
end;

function TTDBotGameState.GetPlayerHitsplatBuffer(): array of THitsplatSample;
begin
  Self.pLock.Enter;
  Result := Self.pHitSplatBuffer.Copy;
  Self.pLock.Leave;
end;

procedure TTDBotGameState.TrackPlayerHitsplats();
  function CountDivineDoses(): Integer;
  begin

  end;

  function IsDuplicate(sample: THitsplatSample): Boolean;
  var
    i: Int32;
  begin
    for i := 0 to High(Self.pHitsplatBuffer) do
      with Self.pHitsplatBuffer[i] do
        if (Hitsplat.Value <> 0) and (Hitsplat.Value = sample.HitSplat.Value) and ((sample.Timestamp - Timestamp) < 50) then
          Exit(True);

    if (sample.HitSplat.Value = 10) and ((sample.Timestamp - Self.pLastDivineConsume) < HITSPLAT_EXPIRE_MS) then
      Exit(True);

    Result := False;
  end;
var
  currentTime: UInt64;
  divineDoses: Integer;
  consumedDivine: Boolean;
  hitsplat: TRSHitsplat;
  hitsplats: TRSHitsplatArray;
  earliestDivineTime: UInt64;
  i: Int32;
begin

  ///TODO LOCKS?????????
  currentTime := GetTimeRunning();
  divineDoses := CountDivineDoses;
  consumedDivine := (Self.pDivineDoses - divineDoses) = 1;

  if consumedDivine then
  begin
    Self.pDivineDoses := divineDoses;

    for i := Low(Self.pHitsplatBuffer) to High(Self.pHitsplatBuffer) do
      with Self.pHitsplatBuffer[i] do
        if (Hitsplat.Value = 10) and ((currentTime - Timestamp) < HITSPLAT_EXPIRE_MS) then
          if (earliestDivineTime = 0) or (Timestamp < earliestDivineTime) then
            earliestDivineTime := Timestamp;

    if earliestDivineTime > 0 then
    begin
      Self.pLastDivineConsume := earliestDivineTime;
      for i := Low(Self.pHitsplatBuffer) to High(Self.pHitsplatBuffer) do
        with Self.pHitsplatBuffer[i] do
          if (Hitsplat.Value = 10) and (Timestamp >= earliestDivineTime) and ((currentTime - Timestamp) < HITSPLAT_EXPIRE_MS) then
            Self.pHitSplatBuffer[i] := [];
    end;
  end;

  if not TRSHitsplat.Find(hitsplats, [MainScreen.GetPlayerBox]) then
    Exit;


  //TODO im here
  for hitsplat in hitsplats do
  begin
    if IsDuplicate([hitsplat, currentTime]) then
      Continue;

    Self.pHitsplatBuffer[Self.pHitSplatBufferIndex] := [hitsplat, currentTime];
    Inc(Self.pHitSplatBufferIndex);
    if Self.pHitSplatBufferIndex >= Length(Self.pHitsplatBuffer) then
      Self.pHitSplatBufferIndex := Low(Self.pHitSplatBuffer);
  end;
end;

function TTDBotGameState.IsPlayerSnared(): Boolean;
begin
  Self.pLock.Enter;
  Result := Self.tdIsCastingSnare;
  Self.pLock.Leave;
end;

procedure TTDBotGameState.FindTormentedDemonSnare();
var
  snareColors : TPointArray;
  snareVisible: Boolean;
begin
  snareColors := Target.FindColor(0, 0, Box(MainScreen.Center, 100, 100));
  if snareColors.Length = 0 then
    Exit;

  snareVisible := InRange(snareColors.Cluster(3).SortFrom(MainScreen.Center)[0].MinAreaCircle.Radius,
      MainScreen.NormalizeDistance(20),
      MainScreen.NormalizeDistance(30));

  Self.tdLock.Enter;
  Self.tdIsCastingSnare := snareVisible;
  Self.tdLock.Leave;
end;

procedure TTDBotGameState.SetTormentedDemonMSPoints(points: TPointArray);
begin
  Self.tdLock.Enter;
  Self.tdMainScreenPoints := points.copy;
  Self.tdLock.Leave;
end;

function TTDBotGameState.GetTormentedDemonMSPoints(): TPointArray;
begin
  Self.tdLock.Enter;
  Result := Self.tdMainScreenPoints.Copy;
  Self.tdLock.Leave;
end;

procedure TTDBotGameState.SetTormentedDemonPosition(position: TPoint);
begin
  Self.tdLock.Enter;
  Self.tdPosition := position;
  Self.tdLock.Leave;
end;

function TTDBotGameState.GetTormentedDemonPosition(): TPoint;
begin
  Self.tdLock.Enter;
  Result := Self.tdPosition;
  Self.tdLock.Leave;
end;

procedure TTDBotGameState.SetTormentedDemonCombatStyle(style: ERSCombatStyle);
begin
  Self.tdLock.Enter;
  Self.tdCombatStyle := style;
  Self.tdLock.Leave;
end;

function TTDBotGameState.GetTormentedDemonCombatStyle(): ERSCombatStyle;
begin
  Self.tdLock.Enter;
  Result := Self.tdCombatStyle;
  Self.tdLock.Leave;
end;

procedure TTDBotGameState.SetTormentedDemonProtectedStyle(style: ERSCombatStyle);
begin
  Self.tdLock.Enter;
  Self.tdProtectedStyle := style;
  Self.tdLock.Leave;
end;

function TTDBotGameState.GetTormentedDemonProtectedStyle(): ERSCombatStyle;
begin
  Self.tdLock.Enter;
  Result := Self.tdProtectedStyle;
  Self.tdLock.Leave;
end;

procedure TTDBotGameState.FindTormentedDemon();
type
  TMMDotOvhCombo = record
    overhead: TRSOverhead;
    minimapDot: TPoint;
  end;

  function FindAndRemoveClosest(var overheads: TRSOverheadArray; out overhead: TRSOverhead; point: TPoint): Boolean;
  var
    i: Integer;
    nearestOverhead: record index: Integer; distance: Double; end;
    distance: Double;
  begin
    for i := 0 to High(overheads) do
    begin
      distance := overheads[i].Position.DistanceTo(point);
      if (nearestOverhead.index = -1) or (distance < nearestOverhead.distance) then
        nearestOverhead := [i, distance];
    end;

    if nearestOverhead.distance > 20 then
      Exit;

    overhead := overheads[nearestOverhead.index];
    overheads.Remove(overheads[nearestOverhead.index]);
    Result := True;
  end;

const
  COMBAT_BOUNDS: TBox = [12040, 32718, 12084, 32782];
var
  d: double;

  minimapDot: TPoint;
  minimapDots: TPointArray;
  overhead: TRSOverhead;
  overheads: TRSOverheadArray;
  compassAngle: Double;
  predictedOverheadPt: TPoint;
  combos: array of
    record
      overhead: TRSOverhead;
      minimapDot: TPoint;
    end;
  i: Int32;
  cuboid: TCuboid;
  points: TPointArray;
begin
  //TODO handle exits differently?? maybe do nothing but timestamp the last update.
  //possibly run a cleanup tasks, log average task times, if last update > average * x% then cleanup assignments

  d := performancetime;
  if not (Self.GetPlayerPosition in COMBAT_BOUNDS) then
  begin
    Exit;
  end;

  minimapDots := Minimap.GetDots(ERSMinimapDot.NPC);
  overheads := OverheadFinder.Find([ERSOverhead.MELEE, ERSOverhead.MAGIC, ERSOverhead.RANGED]);
  if (minimapDots.Length = 0) or (overheads.Length = 0) then
  begin
    Exit;
  end;

  compassAngle := Minimap.GetCompassAngle(False);
  for minimapDot in minimapDots do
  begin
    if overheads.Length = 0 then
      Break;
    predictedOverheadPt := Minimap.Vector2MS(minimapDot.ToVec3(26), compassAngle);
    if FindAndRemoveClosest(overheads, overhead, predictedOverheadPt) then
      combos += [overhead, minimapDot];
  end;

  if combos.Length <> 1 then
  begin
    Exit; //TODO handle more than 1 td??
  end;

  cuboid := Minimap.Point2MSCuboid(combos[0].minimapDot, [2.6,2.6,14], compassAngle);
  points := Target.FindColor($3F589A, 17.7, EColorSpace.HSV, [1.207,0.766,1.029], cuboid.Bounds);
  points := points.Difference(cuboid.Filter(points)).Grow(3).Erode(4).Cluster(1).Largest;

  if points.Length = 0 then
  begin
    Exit;
  end;

  Self.SetTormentedDemonMSPoints(points);
  Self.SetTormentedDemonPosition(combos[0].minimapDot - Minimap.Center + Self.GetPlayerPosition);
  case combos[0].overhead.Overhead of
    ERSOverhead.MELEE: Self.SetTormentedDemonProtectedStyle(ERSCombatStyle.MELEE);
    ERSOverhead.RANGED: Self.SetTormentedDemonProtectedStyle(ERSCombatStyle.RANGED);
    ERSOverhead.MAGIC: Self.SetTormentedDemonProtectedStyle(ERSCombatStyle.MAGIC);
  end;

  if (performancetime - d) > 7 then
    writeln 'TTDBotGameState.FindTormentedDemon ' + tostr(performancetime - d);
end;

procedure TTDBotGameState.AddProjectileSample(detectedStyle: ERSCombatStyle);
begin
  Self.tdLock.Enter;
  with Self.tdProjectileBuffer[Self.tdProjectileBufferIndex] do
  begin
    Style := detectedStyle;
    TimeStamp := Time;
  end;

  Inc(Self.tdProjectileBufferIndex);
  if Self.tdProjectileBufferIndex > High(Self.tdProjectileBuffer) then
    Self.tdProjectileBufferIndex := Low(Self.tdProjectileBuffer);

  Self.tdLock.Leave;
end;

function TTDBotGameState.GetProjectileStyleConfidence(out style: ERSCombatStyle): Single;
var
  currentTime: UInt64;
  sample: TProjectileSample;
  total, best: Integer;
  counts: array[ERSCombatStyle.MAGIC..ERSCombatStyle.RANGED] of Integer;
begin
  currentTime := GetTimeRunning;
  Self.tdLock.Enter;
  for sample in Self.tdProjectileBuffer do
  begin
    if (currentTime - sample.Timestamp) > PROJECTILE_SAMPLE_EXPIRE_MS then
      Continue;
    Inc(counts[sample.Style]);
    Inc(total);
  end;

  if total = 0 then
    Exit;

  if counts[ERSCombatStyle.MAGIC] > counts[ERSCombatStyle.RANGED] then
    style := ERSCombatStyle.MAGIC
  else if counts[ERSCombatStyle.MAGIC] < counts[ERSCombatStyle.RANGED] then
    style := ERSCombatStyle.RANGED
  else
    style := ERSCombatStyle.UNKNOWN;

  Result := counts[style] / total;
  Self.tdLock.Leave;
end;

function TTDBotGameState.FindMagicProjectile(searchArea: TBox): Boolean;
const
  PROJECTILE_COLOR: TColorTolerance = [$40B2DF, 4.405, EColorSpace.HSL, [1.747, 0.513, 0.742]];
  MIN_RADIUS = 5; MAX_RADIUS = 10;
  MIN_DENSITY = 0.4; MAX_DENSITY = 0.65;
var
  points, cluster: TPointArray;
  i: Integer;
  circ: TCircle;
  minRadiusNorm, maxRadiusNorm: Integer;
begin
  points := Target.FindColor(PROJECTILE_COLOR, searchArea)
    .ExcludeBox(MainScreen.GetPlayerBox)
    .ExcludePoints(Self.GetTormentedDemonMSPoints)
    .Grow(MainScreen.NormalizeDistance(2))
    .Erode(MainScreen.NormalizeDistance(1));

  minRadiusNorm := MainScreen.NormalizeDistance(MIN_RADIUS);

  if points.Length < (Pi * Sqr(minRadiusNorm) * MIN_DENSITY) then
    Exit;

  maxRadiusNorm := MainScreen.NormalizeDistance(MAX_RADIUS);

  for cluster in points.Cluster(1.5) do
  begin
    circ := cluster.MinAreaCircle;
    if InRange(circ.Radius, minRadiusNorm, maxRadiusNorm) and InRange(cluster.Length / circ.Area, MIN_DENSITY, MAX_DENSITY) then
        Exit(True);
  end;
end;

function TTDBotGameState.FindRangedProjectile(searchArea: TBox): Boolean;
begin
  //TODO this is boring
end;

procedure TTDBotGameState.TrackTormentedDemonCombatStyle();
var
  searchArea: TBox;
  detectedStyle: ERSCombatStyle;
  hitsplats: array of THitSplatSample;
  i: Integer;

begin
  searchArea := MainScreen.GetPlayerBox.Combine(Self.GetTormentedDemonMSPoints.Bounds);
  if Self.FindMagicProjectile(searchArea) then
    Self.AddProjectileSample(ERSCombatStyle.MAGIC);
  if Self.FindRangedProjectile(searchArea) then
    Self.AddProjectileSample(ERSCombatStyle.RANGED);

  if Self.GetTormentedDemonCombatStyle = ERSCombatStyle.UNKNOWN then
    if Self.GetProjectileStyleConfidence(detectedStyle) > 0.7 then
      Self.SetTormentedDemonCombatStyle(detectedStyle);

  //TODO melee distance, following tracking

  if Self.GetTormentedDemonCombatStyle <> ERSCombatStyle.UNKNOWN then
  begin
    hitsplats := Self.GetPlayerHitsplatBuffer();
    for i := 0 to High(hitsplats) do
    begin
      if (hitsplats[i].HitSplat.Color = ERSHitSplat.RED) and InRange(GetTimeRunning - hitsplats[i].TimeStamp, 200, HITSPLAT_EXPIRE_MS) then
      begin
        //TODO analyze current style, demon distance, change styles because we're taking damage!
      end;
    end;
  end;

end;

procedure TTDBotGameState.Start();
begin
  Self.pLock := TLock.Create;
  Self.tdLock := TLock.Create;
  Self.TaskManager.Init('game_state', CPUInfo.CoreCount);

  Self.TaskManager.Schedule(@Self.ReadPlayerPosition);
  Self.TaskManager.Schedule(@Self.ReadGameTabs);
  Self.TaskManager.Schedule(@Self.FindTormentedDemon);
  Self.TaskManager.Schedule(@Self.FindTormentedDemonSnare);
  Self.TaskManager.Schedule(@Self.TrackTormentedDemonCombatStyle);
  Self.TaskManager.Schedule(@Self.TrackPlayerHitsplats);

  WriteLn('ReadPlayerPosition: ', ToStr(@Self.ReadPlayerPosition));
  Writeln('FindTormentedDemon: ', ToStr(@Self.FindTormentedDemon));
end;

var
  GameState: TTDBotGameState;




