{$IFNDEF WASPLIB_OSRS} {$I WaspLib/osrs.simba} {$ENDIF}
{$include_once task_manager.simba}
{$INCLUDE_ONCE overhead_finder.simba}
{$INCLUDE_ONCE combat_types.simba}

type
  TTDBotGameState = record
    TaskManager: TReschedulingTaskManager;
    ClockModified: Boolean;

    Player: record
      Lock: TLock;

      Position: TPoint;

      ActivePrayers: TRSPrayerSet;
      InventoryItems: TRSItemArray;
    end;

    TormentedDemon: record
      Lock: TLock;

      ProtectionPrayer: ERSPrayer;
      CombatStyle: ERSCombatStyle;
      MainScreenPoints: TPointArray;
      Position: TPoint;
      Health: Integer;
      IsCastingSnare: Boolean;
    end;
  end;

procedure TTDBotGameState.SetPlayerPosition(position: TPoint);
begin
  Self.Player.Lock.Enter;
  Self.Player.Position := position;
  Self.Player.Lock.Leave;
end;

function TTDBotGameState.GetPlayerPosition(): TPoint;
begin
  Self.Player.Lock.Enter;
  Result := Self.Player.Position;
  Self.Player.Lock.Leave;
end;

procedure TTDBotGameState.ReadPlayerPosition();
begin
  if RSClient.IsLoggedIn then
   Self.SetPlayerPosition(Map.Position);
end;

procedure TTDBotGameState.SetInventoryItems(items: TRSItemArray);
begin
  Self.Player.Lock.Enter;
  Self.Player.InventoryItems := items.Copy;
  Self.Player.Lock.Leave;
end;

function TTDBotGameState.GetInventoryItems(): TRSItemArray;
begin
  Self.Player.Lock.Enter;
  Result := Self.Player.InventoryItems.Copy;
  Self.Player.Lock.Leave;
end;

procedure TTDBotGameState.SetPlayerActivePrayers(prayers: TRSPrayerSet);
begin
  Self.Player.Lock.Enter;
  Self.Player.ActivePrayers := prayers;
  Self.Player.Lock.Leave;
end;

function TTDBotGameState.GetPlayerActivePrayers(): TRSPrayerSet;
begin
  Self.Player.Lock.Enter;
  Result := Self.Player.ActivePrayers;
  Self.Player.Lock.Leave;
end;

procedure TTDBotGameState.ReadGameTabs();
var
  slot, i: Integer;
  emptySlots: TIntegerArray;
  discovered, items: TRSItemArray;
begin
  case GameTabs.GetCurrent of
    ERSGameTab.INVENTORY:
    begin
      emptySlots := Inventory.Slots.GetEmpty;
      discovered := Inventory.Items.DiscoverAll;
      if emptySlots.Length + discovered.Length <> 28 then
        Exit;

      SetLength(items, 28);
      for slot := 0 to 27 do
      begin
        if slot in emptySlots then
          Continue;

        items[slot] := discovered[i];
        Inc(i);
      end;
      Self.SetInventoryItems(items);
    end;

    ERSGameTab.PRAYER: Self.SetPlayerActivePrayers(Prayer.GetActivePrayers);
  end;
end;

function TTDBotGameState.IsPlayerSnared(): Boolean;
begin
  Self.Player.Lock.Enter;
  Result := Self.TormentedDemon.IsCastingSnare;
  Self.Player.Lock.Leave;
end;

procedure TTDBotGameState.FindTormentedDemonSnare();
var
  snareColors : TPointArray;
  snareVisible: Boolean;
begin
  snareColors := Target.FindColor(0, 0, Box(MainScreen.Center, 100, 100));
  if snareColors.Length = 0 then
    Exit;

  snareVisible := InRange(snareColors.Cluster(3).SortFrom(MainScreen.Center)[0].MinAreaCircle.Radius,
      MainScreen.NormalizeDistance(20),
      MainScreen.NormalizeDistance(30));

  Self.TormentedDemon.Lock.Enter;
  Self.TormentedDemon.IsCastingSnare := snareVisible;
  Self.TormentedDemon.Lock.Leave;
end;

procedure TTDBotGameState.SetTormentedDemonMSPoints(points: TPointArray);
begin
  Self.TormentedDemon.Lock.Enter;
  Self.TormentedDemon.MainScreenPoints := points.copy;
  Self.TormentedDemon.Lock.Leave;
end;

function TTDBotGameState.GetTormentedDemonMSPoints(): TPointArray;
begin
  Self.TormentedDemon.Lock.Enter;
  Result := Self.TormentedDemon.MainScreenPoints.Copy;
  Self.TormentedDemon.Lock.Leave;
end;

procedure TTDBotGameState.SetTormentedDemonPosition(position: TPoint);
begin
  Self.TormentedDemon.Lock.Enter;
  Self.TormentedDemon.Position := position;
  Self.TormentedDemon.Lock.Leave;
end;

function TTDBotGameState.GetTormentedDemonPosition(): TPoint;
begin
  Self.TormentedDemon.Lock.Enter;
  Result := Self.TormentedDemon.Position;
  Self.TormentedDemon.Lock.Leave;
end;

procedure TTDBotGameState.SetTormentedDemonCombatStyle(style: ERSCombatStyle);
begin
  Self.TormentedDemon.Lock.Enter;
  Self.TormentedDemon.CombatStyle := style;
  Self.TormentedDemon.Lock.Leave;
end;

function TTDBotGameState.GetTormentedDemonCombatStyle(): ERSCombatStyle;
begin
  Self.TormentedDemon.Lock.Enter;
  Result := Self.TormentedDemon.CombatStyle;
  Self.TormentedDemon.Lock.Leave;
end;

procedure TTDBotGameState.SetTormentedDemonProtectionPrayer(prayer: ERSPrayer);
begin
  Self.TormentedDemon.Lock.Enter;
  Self.TormentedDemon.ProtectionPrayer := prayer;
  Self.TormentedDemon.Lock.Leave;
end;

function TTDBotGameState.GetTormentedDemonProtectionPrayer(): ERSPrayer;
begin
  Self.TormentedDemon.Lock.Enter;
  Result := Self.TormentedDemon.ProtectionPrayer;
  Self.TormentedDemon.Lock.Leave;
end;

procedure TTDBotGameState.FindTormentedDemon();
type
  TMMDotOvhCombo = record
    overhead: TRSOverhead;
    minimapDot: TPoint;
  end;

  function FindAndRemoveClosest(var overheads: TRSOverheadArray; out overhead: TRSOverhead; point: TPoint): Boolean;
  var
    i: Integer;
    nearestOverhead: record index: Integer; distance: Double; end;
    distance: Double;
  begin
    for i := 0 to High(overheads) do
    begin
      distance := overheads[i].Position.DistanceTo(point);
      if (nearestOverhead.index = -1) or (distance < nearestOverhead.distance) then
        nearestOverhead := [i, distance];
    end;

    if nearestOverhead.distance > 20 then
      Exit;

    overhead := overheads[nearestOverhead.index];
    overheads.Remove(overheads[nearestOverhead.index]);
    Result := True;
  end;

const
  COMBAT_BOUNDS: TBox = [12040, 32718, 12084, 32782];
var
  d: double;

  minimapDot: TPoint;
  minimapDots: TPointArray;
  overhead: TRSOverhead;
  overheads: TRSOverheadArray;
  compassAngle: Double;
  predictedOverheadPt: TPoint;
  combos: array of
    record
      overhead: TRSOverhead;
      minimapDot: TPoint;
    end;
  i: Int32;
  cuboid: TCuboid;
  points: TPointArray;
begin
  //TODO handle exits differently?? maybe do nothing but timestamp the last update.
  //possibly run a cleanup tasks, log average task times, if last update > average * x% then cleanup assignments

  d := performancetime;
  if not (Self.GetPlayerPosition in COMBAT_BOUNDS) then
  begin
    writeln 'early exit, not in combat bounds';
    Exit;
  end;

  minimapDots := Minimap.GetDots(ERSMinimapDot.NPC);
  overheads := OverheadFinder.Find([ERSOverhead.MELEE, ERSOverhead.MAGIC, ERSOverhead.RANGED]);
  if (minimapDots.Length = 0) or (overheads.Length = 0) then
  begin
    writeln('early exit, mmdots found=', minimapDots.Length, ' overheads found=', overheads.Length);
    Exit;
  end;

  compassAngle := Minimap.GetCompassAngle(False);
  for minimapDot in minimapDots do
  begin
    if overheads.Length = 0 then
      Break;
    predictedOverheadPt := Minimap.Vector2MS(minimapDot.ToVec3(26), compassAngle);
    if FindAndRemoveClosest(overheads, overhead, predictedOverheadPt) then
      combos += [overhead, minimapDot];
  end;

  if combos.Length <> 1 then
  begin
    writeln('early exit, combo length mismatch ', combos.Length);
    Exit; //TODO handle more than 1 td??
  end;
  //[$3F589A, 17.700, EColorSpace.HSV, [1.207, 0.766, 1.029]]

  cuboid := Minimap.Point2MSCuboid(combos[0].minimapDot, [2.6,2.6,14], compassAngle);
  points := Target.FindColor($3F589A, 17.7, EColorSpace.HSV, [1.207,0.766,1.029], cuboid.Bounds);
  points := points.Difference(cuboid.Filter(points)).Grow(3).Erode(4).Cluster(1).Largest;

  if points.Length = 0 then
  begin
    writeln 'early exit, no colors found';
    Exit;
  end;

  Self.SetTormentedDemonMSPoints(points);
  Self.SetTormentedDemonPosition(combos[0].minimapDot - Minimap.Center + Self.GetPlayerPosition);
  case combos[0].overhead.Overhead of
    ERSOverhead.MELEE: Self.SetTormentedDemonProtectionPrayer(ERSPrayer.PROTECT_FROM_MELEE);
    ERSOverhead.RANGED: Self.SetTormentedDemonProtectionPrayer(ERSPrayer.PROTECT_FROM_MISSILES);
    ERSOverhead.MAGIC: Self.SetTormentedDemonProtectionPrayer(ERSPrayer.PROTECT_FROM_MAGIC);
  end;
  writeln 'TTDBotGameState.FindTormentedDemon ' + tostr(performancetime - d);
end;

procedure TTDBotGameState.Start();
begin
  Self.Player.Lock := TLock.Create;
  Self.TormentedDemon.Lock := TLock.Create;
  Self.TaskManager.Init('game_state', CPUInfo.CoreCount);

  Self.TaskManager.Schedule(@Self.ReadPlayerPosition);
  Self.TaskManager.Schedule(@Self.ReadGameTabs);
  Self.TaskManager.Schedule(@Self.FindTormentedDemon);
  Self.TaskManager.Schedule(@Self.FindTormentedDemonSnare);

  WriteLn('ReadPlayerPosition: ', ToStr(@Self.ReadPlayerPosition));
  Writeln('FindTormentedDemon: ', ToStr(@Self.FindTormentedDemon));
end;

var
  GameState: TTDBotGameState;




