{$IFNDEF WASPLIB_OSRS} {$I WaspLib/osrs.simba} {$ENDIF}
{$include_once task_manager.simba}
{$INCLUDE_ONCE overhead_finder.simba}
{$INCLUDE_ONCE combat_types.simba}
{$INCLUDE_ONCE tbox.simba}
{$INCLUDE_ONCE inventory.simba}
{$INCLUDE_ONCE sample_buffer.simba}

const
  HITSPLAT_BUFFER_SIZE = 50;
  HITSPLAT_EXPIRE_MS = 1000;
  PROJECTILE_BUFFER_SIZE = 20;
  PROJECTILE_SAMPLE_EXPIRE_MS = 2000;

type

  TGameStateObserver = record
    TaskManager: TReschedulingTaskManager;

    pLock: TLock;
    pPosition: TPoint;
    pPositionBuffer: TSampleBuffer;
    pActivePrayers: TRSPrayerSet;
    pInventoryItems: TRSDiscoveredInventory;
    pHitsplatBuffer: TSampleBuffer;
    pDivineDoses: Integer;
    pLastDivineConsume: Integer;

    tdLock: TLock;
    tdProtectedStyle: ERSCombatStyle;
    tdCombatStyle: ERSCombatStyle;
    tdMainScreenPoints: TPointArray;
    tdPosition: TPoint;
    tdPositionBuffer: TSampleBuffer;
    tdHealth: Integer;
    tdIsCastingSnare: Boolean;
    tdProjectileBuffer: TSampleBuffer;
  end;

  TGameState = record
    Observer: TGameStateObserver;
  end;

function TGameStateObserver.GetPlayerPosition(): TPoint;
begin
  Self.pLock.Enter;
  Result := Self.pPosition;
  Self.pLock.Leave;
end;

function TGameStateObserver.GetInventoryItems(): TRSDiscoveredInventory;
begin
  Self.pLock.Enter;
  Result := Self.pInventoryItems.Copy;
  Self.pLock.Leave;
end;

function TGameStateObserver.GetPlayerActivePrayers(): TRSPrayerSet;
begin
  Self.pLock.Enter;
  Result := Self.pActivePrayers;
  Self.pLock.Leave;
end;

procedure TGameStateObserver.SetPlayerActivePrayers(prayers: TRSPrayerSet);
begin
  Self.pLock.Enter;
  Self.pActivePrayers := prayers;
  Self.pLock.Leave;
end;

procedure TGameStateObserver.ReadInventoryTab();
begin
  if ChooseOption.IsOpen and ChooseOption.Bounds.Intersects(GameTab.Bounds) then
    Exit;

  // TODO Self.SetInventoryItems(Inventory.Items.DiscoverAllEx);
end;

procedure TGameStateObserver.ReadPrayerTab();
var
  b: TBox;
begin
  ////triple ensure that the prayer tab is open to prevent false results.
  //if Prayer.IsOpen and Prayer.Find(ERSPrayer.THICK_SKIN, b) and Prayer.Find(ERSPrayer.PROTECT_FROM_MELEE, b) then
  //  Self.SetPlayerActivePrayers(Prayer.GetActivePrayers);
end;

procedure TGameStateObserver.ReadGameTabs();
begin
  case GameTabs.GetCurrent of
    ERSGameTab.INVENTORY: Self.ReadInventoryTab;
    ERSGameTab.PRAYER: Self.ReadPrayerTab;
  end;
  Sleep(50);
end;

procedure TGameStateObserver.TrackPlayerPosition();
var
  position: TPoint;
  previous: TSample;
begin
  //if RSClient.IsLoggedIn then
  position := Map.Position;

  Self.pLock.Enter;
  Self.pPosition := position;
  with Self.pPositionBuffer do
  begin
    previous := Data[(Index - 1 + Data.Length) mod Data.Length];
    if (previous.Data = nil) or ((previous.Data <> nil) and (TPoint(previous.Data^) <> position)) then
      Add(@position);
  end;
  Self.pLock.Leave;
end;

procedure TGameStateObserver.TrackPlayerHitsplats();
  function CountDivineDoses(): Integer;
  var
    item: String;
    items: TStringArray;
  begin
    for items in Self.GetInventoryItems do
      for item in items do
      begin
        if Pos('Divine', item) <= 0 then
          Continue;
        Inc(Result, item.ExtractInteger(0));
        Break;
      end;
  end;

var
  currentTime: UInt64;
  divineDoses: Integer;
  hitsplat: TRSHitsplat;
  hitsplats: TRSHitsplatArray;
  sample: TSample;
  samples: TSampleArray;
  i: Int32;
begin
  //no hitsplats found, no hitsplats to track
  if not TRSHitsplat.Find(hitsplats, [MainScreen.GetPlayerBox]) then
    Exit;

  currentTime := GetTimeRunning();
  divineDoses := CountDivineDoses;

  for hitsplat in hitsplats do
  begin
    //skip all hitsplats that arent red because we only care about tracking damage to the player
    if hitsplat.Color <> ERSHitSplat.RED then
      Continue;

    //if hitsplat value is a 10 then its possible it's related to a divine consumption
    if (hitsplat.Value = 10) then
    begin
      //if we consumed a divine potion then we need to look for the oldest 10 hitsplat,
      //within the last 300ms, and remove every 10 entry from that
      //point while setting the last consume time at the time of that hitsplat
      if (Self.pDivineDoses - divineDoses) = 1 then
      begin
        Self.pDivineDoses := divineDoses;
        Self.pLock.Enter;
        samples := Self.pHitsplatBuffer.GetSamples(0, 300);
        Self.pLock.Leave;
        for sample in samples do
          if TRSHitsplat(sample.Data^).Value = 10 then
            Self.pLastDivineConsume := sample.Time;
        //we're done with that setof samples so we can free them
        samples.Free;
        //now we must manually clean up any 10 valued hitsplats since the time of divine consumption.
        Self.pLock.Enter;
        for i := 0 to Self.pHitsplatBuffer.Data.High do
          with Self.pHitsplatBuffer.Data[i] do
            if (Data <> nil) and (Time >= Self.pLastDivineConsume) and (TRSHitsplat(Data^).Value = 10) then
            begin
              FreeMem(Data);
              Data := nil;
              Time := 0;
            end;
        Self.pLock.Leave;
      end;

      //if it's still possible for a divine hitsplat to be on screen then we must ignore it.
      if (currentTime - Self.pLastDivineConsume) < HITSPLAT_EXPIRE_MS then
        Continue;
    end;

    //check if the current hitsplat is a duplicate of the last entry and last entry is
    // not expired, if so ignore, if not add it to the buffer
    Self.pLock.Enter;
    try
      with Self.pHitsplatBuffer do
        sample := Data[(Index - 1 + Length(Data)) mod Length(Data)];
      if (sample.Data <> nil) and (TRSHitsplat(sample.Data^).Value = hitsplat.Value) and (currentTime - sample.Time < HITSPLAT_EXPIRE_MS) then
        Continue
      else
        Self.pHitsplatBuffer.Add(@hitsplat);
    finally
      Self.pLock.Leave;
    end;
  end;
end;

function TGameStateObserver.HasTDCastSnare(): Boolean;
begin
  Self.pLock.Enter;
  Result := Self.tdIsCastingSnare;
  Self.pLock.Leave;
end;

function TGameStateObserver.GetTormentedDemonMSPoints(): TPointArray;
begin
  Self.tdLock.Enter;
  Result := Self.tdMainScreenPoints.Copy;
  Self.tdLock.Leave;
end;

procedure TGameStateObserver.SetTormentedDemonMSPoints(points: TPointArray);
begin
  Self.tdLock.Enter;
  Self.tdMainScreenPoints := points.copy;
  Self.tdLock.Leave;
end;

function TGameStateObserver.GetTormentedDemonPosition(): TPoint;
begin
  Self.tdLock.Enter;
  Result := Self.tdPosition;
  Self.tdLock.Leave;
end;

procedure TGameStateObserver.SetTormentedDemonPosition(position: TPoint);
begin
  Self.tdLock.Enter;
  Self.tdPosition := position;
  Self.tdLock.Leave;
end;

function TGameStateObserver.GetTormentedDemonCombatStyle(): ERSCombatStyle;
begin
  Self.tdLock.Enter;
  Result := Self.tdCombatStyle;
  Self.tdLock.Leave;
end;

procedure TGameStateObserver.SetTormentedDemonCombatStyle(style: ERSCombatStyle);
begin
  Self.tdLock.Enter;
  Self.tdCombatStyle := style;
  Self.tdLock.Leave;
end;

function TGameStateObserver.GetTormentedDemonProtectedStyle(): ERSCombatStyle;
begin
  Self.tdLock.Enter;
  Result := Self.tdProtectedStyle;
  Self.tdLock.Leave;
end;

procedure TGameStateObserver.SetTormentedDemonProtectedStyle(style: ERSCombatStyle);
begin
  Self.tdLock.Enter;
  Self.tdProtectedStyle := style;
  Self.tdLock.Leave;
end;

procedure TGameStateObserver.FindTormentedDemonSnare();
var
  snareColors : TPointArray;
  snareVisible: Boolean;
begin
  snareColors := Target.FindColor(0, 0, Box(MainScreen.Center, 100, 100));
  if snareColors.Length = 0 then
    Exit;

  snareVisible := InRange(snareColors.Cluster(3).SortFrom(MainScreen.Center)[0].MinAreaCircle.Radius,
      MainScreen.NormalizeDistance(20),
      MainScreen.NormalizeDistance(30));

  Self.tdLock.Enter;
  Self.tdIsCastingSnare := snareVisible;
  Self.tdLock.Leave;
end;

procedure TGameStateObserver.FindTormentedDemon();
type
  TMMDotOvhCombo = record
    overhead: TRSOverhead;
    minimapDot: TPoint;
  end;

  function FindAndRemoveClosest(var overheads: TRSOverheadArray; out overhead: TRSOverhead; point: TPoint): Boolean;
  var
    i: Integer;
    nearestOverhead: record index: Integer; distance: Double; end;
    distance: Double;
  begin
    for i := 0 to High(overheads) do
    begin
      distance := overheads[i].Position.DistanceTo(point);
      if (nearestOverhead.index = -1) or (distance < nearestOverhead.distance) then
        nearestOverhead := [i, distance];
    end;

    if nearestOverhead.distance > 20 then
      Exit;

    overhead := overheads[nearestOverhead.index];
    overheads.Remove(overheads[nearestOverhead.index]);
    Result := True;
  end;

const
  COMBAT_BOUNDS: TBox = [12040, 32718, 12084, 32782];
var
  d: double;

  minimapDot: TPoint;
  minimapDots: TPointArray;
  overhead: TRSOverhead;
  overheads: TRSOverheadArray;
  compassAngle: Double;
  predictedOverheadPt: TPoint;
  combos: array of
    record
      overhead: TRSOverhead;
      minimapDot: TPoint;
    end;
  cuboid: TCuboid;
  points: TPointArray;
begin
  //TODO handle exits differently?? maybe do nothing but timestamp the last update.
  //possibly run a cleanup tasks, log average task times, if last update > average * x% then cleanup assignments

  d := performancetime;
  if not (Self.GetPlayerPosition in COMBAT_BOUNDS) then
  begin
    Exit;
  end;

  minimapDots := Minimap.GetDots(ERSMinimapDot.NPC);
  overheads := OverheadFinder.Find([ERSOverhead.MELEE, ERSOverhead.MAGIC, ERSOverhead.RANGED]);
  if (minimapDots.Length = 0) or (overheads.Length = 0) then
  begin
    Exit;
  end;

  compassAngle := Minimap.GetCompassAngle(False);
  for minimapDot in minimapDots do
  begin
    if overheads.Length = 0 then
      Break;
    predictedOverheadPt := Minimap.Vector2MS(minimapDot.ToVec3(26), compassAngle);
    if FindAndRemoveClosest(overheads, overhead, predictedOverheadPt) then
      combos += [overhead, minimapDot];
  end;

  if combos.Length <> 1 then
  begin
    Exit; //TODO handle more than 1 td??
  end;

  cuboid := Minimap.Point2MSCuboid(combos[0].minimapDot, [2.6,2.6,14], compassAngle);
  points := Target.FindColor($3F589A, 17.7, EColorSpace.HSV, [1.207,0.766,1.029], cuboid.Bounds);
  points := points.Difference(cuboid.Filter(points)).Grow(3).Erode(4).Cluster(1).Largest;

  if points.Length = 0 then
  begin
    Exit;
  end;

  Self.SetTormentedDemonMSPoints(points);
  Self.SetTormentedDemonPosition(combos[0].minimapDot - Minimap.Center + Self.GetPlayerPosition);
  case combos[0].overhead.Overhead of
    ERSOverhead.MELEE: Self.SetTormentedDemonProtectedStyle(ERSCombatStyle.MELEE);
    ERSOverhead.RANGED: Self.SetTormentedDemonProtectedStyle(ERSCombatStyle.RANGED);
    ERSOverhead.MAGIC: Self.SetTormentedDemonProtectedStyle(ERSCombatStyle.MAGIC);
  end;

  if (performancetime - d) > 7 then
    writeln 'TGameStateObserver.FindTormentedDemon ' + tostr(performancetime - d);
end;

function TGameStateObserver.GetProjectileStyleConfidence(out style: ERSCombatStyle): Single;
const
  PROJECTILE_SAMPLE_AGE = 3000;
var
  currentTime: UInt64;
  sample: TSample;
  samples: TSampleArray;
  total: Integer;
  counts: array[ERSCombatStyle.MAGIC..ERSCombatStyle.RANGED] of Integer;
begin
  currentTime := GetTimeRunning;
  Self.tdLock.Enter;
  samples := Self.tdProjectileBuffer.GetSamples(0, PROJECTILE_SAMPLE_AGE);
  Self.tdLock.Leave;

  if samples.Length = 0 then
    Exit;

  for sample in samples do
  begin
    Inc(counts[ERSCombatStyle(sample.Data^)]);
    Inc(total);
  end;

  if counts[ERSCombatStyle.MAGIC] > counts[ERSCombatStyle.RANGED] then
    style := ERSCombatStyle.MAGIC
  else if counts[ERSCombatStyle.MAGIC] < counts[ERSCombatStyle.RANGED] then
    style := ERSCombatStyle.RANGED
  else
    style := ERSCombatStyle.UNKNOWN;

  Result := counts[style] / total;
end;

function TGameStateObserver.FindMagicProjectile(searchArea: TBox): Boolean;
const
  PROJECTILE_COLOR: TColorTolerance = [$40B2DF, 4.405, EColorSpace.HSL, [1.747, 0.513, 0.742]];
  MIN_RADIUS = 5; MAX_RADIUS = 10;
  MIN_DENSITY = 0.4; MAX_DENSITY = 0.65;
var
  points, cluster: TPointArray;
  circ: TCircle;
  minRadiusNorm, maxRadiusNorm: Integer;
begin
  points := Target.FindColor(PROJECTILE_COLOR, searchArea)
    .ExcludeBox(MainScreen.GetPlayerBox)
    .ExcludePoints(Self.GetTormentedDemonMSPoints)
    .Grow(MainScreen.NormalizeDistance(2))
    .Erode(MainScreen.NormalizeDistance(1));

  minRadiusNorm := MainScreen.NormalizeDistance(MIN_RADIUS);

  if points.Length < (Pi * Sqr(minRadiusNorm) * MIN_DENSITY) then
    Exit;

  maxRadiusNorm := MainScreen.NormalizeDistance(MAX_RADIUS);

  for cluster in points.Cluster(1.5) do
  begin
    circ := cluster.MinAreaCircle;
    if InRange(circ.Radius, minRadiusNorm, maxRadiusNorm) and InRange(cluster.Length / circ.Area, MIN_DENSITY, MAX_DENSITY) then
        Exit(True);
  end;
end;

function TGameStateObserver.FindRangedProjectile(searchArea: TBox): Boolean;
begin
  //TODO this is boring
end;

function TGameStateObserver.IsPlayerSteppingAway(): Boolean;
const
  MIN_SAMPLE_AMT = 8;
  MIN_CONFIDENCE = 0.8;
  TD_POS_AGE_DIFF = 200;
  POS_CLUSTER_TIME_FRAME = 90;

var
  playerSamples: TSampleArray;
  tdPosition: TPoint;
  i: Integer;
  currentTime: UInt64;

  procedure GetPlayerSamples();
  begin
    Self.pLock.Enter;
    playerSamples :=  Self.pPositionBuffer.GetSamples(0, 1800);
    Self.pLock.Leave;
  end;

  procedure GetTDPosition();
  var
    age: Integer;
    samples: TSampleArray;
  begin
    age := GetTimeRunning - playerSamples.First.Time;
    Self.tdLock.Enter;
    samples := Self.tdPositionBuffer.GetSamples(age - TD_POS_AGE_DIFF, age + TD_POS_AGE_DIFF, False);
    Self.tdLock.Leave;
    try
      if samples.Length = 0 then
        Exit;
      tdPosition := TPoint(samples.First.Data^);
    finally
      samples.Free;
    end;
  end;

  function CalculateProjectionConfidence(): Single;
  var
    currentPosition, previousPosition: TPoint;
    direction: TVector2;
    previousProjection, currentProjection: Single;
    stepScore: Integer;
  begin
    previousPosition := TPoint(playerSamples.First.Data^);
    direction := TPoint(previousPosition - tdPosition).toVec2.Normalize;

    for i := playerSamples.Low to playerSamples.High - 1 do
    begin
      previousPosition := TPoint(playerSamples[i + 1].Data^);
      currentPosition := TPoint(playerSamples[i].Data^);
      previousProjection := TPoint(previousPosition - tdPosition).ToVec2.Dot(Direction);
      currentProjection := TPoint(currentPosition - tdPosition).ToVec2.Dot(Direction);
      if currentProjection > previousProjection then
      begin
        Inc(stepScore);
        if (currentTime - playerSamples[i].Time) <= POS_CLUSTER_TIME_FRAME then
          Inc(stepScore, 3);
      end;
    end;

    Result := stepScore / (playerSamples.Length * 4);
  end;

begin
  currentTime := GetTimeRunning;

  GetPlayerSamples;
  if playerSamples.Length < MIN_SAMPLE_AMT then
    Exit;

  GetTDPosition;
  if tdPosition = [] then
    Exit;

  Result := CalculateProjectionConfidence >= MIN_CONFIDENCE;
end;

procedure TGameStateObserver.TrackTormentedDemonCombatStyle();
const
  MELEE_DISTANCE_THRESHOLD = 8;
  PROJECTILE_CONFIDENCE_HI = 0.7;
  PROJECTILE_CONFIDENCE_LO = 0.5;
var
  searchArea: TBox;
  foundMagic, foundRanged: Boolean;
  projectileStyleConfidence: Single;
  style, detectedProjectileStyle: ERSCombatStyle;
  hitsplats: TSampleArray;
  i: Int32;
  activeProtection: ERSPrayer;
begin
  //search for and log any projectile found
  searchArea := MainScreen.GetPlayerBox.Combine(Self.GetTormentedDemonMSPoints.Bounds);
  foundMagic := Self.FindMagicProjectile(searchArea);
  foundRanged := Self.FindRangedProjectile(searchArea);
  if foundMagic or foundRanged then
  begin
    Self.tdLock.Enter;
    if foundMagic then
    begin
      style := ERSCombatStyle.MAGIC;
      Self.tdProjectileBuffer.Add(@style);
    end;
    if foundRanged then
    begin
      style := ERSCombatStyle.RANGED;
      Self.tdProjectileBuffer.Add(@style);
    end;
    Self.tdLock.Leave;
  end;

  projectileStyleConfidence := Self.GetProjectileStyleConfidence(detectedProjectileStyle);

  //if combat style is unknown and we're confident in a projectile type then set style
  if Self.GetTormentedDemonCombatStyle = ERSCombatStyle.UNKNOWN then
    if projectileStyleConfidence > PROJECTILE_CONFIDENCE_HI then
      Self.SetTormentedDemonCombatStyle(detectedProjectileStyle);

  //TODO melee distance, following tracking

  //Check if we're taking damage, exit if not
  Self.pLock.Enter;
  hitsplats := Self.pHitsplatBuffer.GetSamples(200, 2000);
  Self.pLock.Leave;
  for i := 0 to High(hitsplats) do
    if TRSHitsplat(hitsplats[i].Data^).Color = ERSHitsplat.RED then
      Break
    else if i = High(hitsplats) then
      Exit;

  //find active protection prayer, ERSPrayer(-1) if none
  for activeProtection in [ERSPrayer.PROTECT_FROM_MELEE, ERSPrayer.PROTECT_FROM_MISSILES, ERSPrayer.PROTECT_FROM_MAGIC, ERSPrayer(-1)] do
    if activeProtection in Self.GetPlayerActivePrayers then
      Break;

  //if the correct prayer isnt active then exit, we're waiting for combat to turn the prayer on.
  case Self.GetTormentedDemonCombatStyle of
    ERSCombatStyle.MELEE  :  if activeProtection <> ERSPrayer.PROTECT_FROM_MELEE    then Exit;
    ERSCombatStyle.RANGED :  if activeProtection <> ERSPrayer.PROTECT_FROM_MISSILES then Exit;
    ERSCombatStyle.MAGIC  :  if activeProtection <> ERSPrayer.PROTECT_FROM_MAGIC    then Exit;
  end;

  //Check if we're confident in a projectile type and that style is not our current set style
  if (projectileStyleConfidence > PROJECTILE_CONFIDENCE_HI) and (detectedProjectileStyle <> Self.GetTormentedDemonCombatStyle) then
  begin
    Self.SetTormentedDemonCombatStyle(detectedProjectileStyle);
    Exit;
  end;

  //Check if tormented demon is out of melee damage
  if Self.GetTormentedDemonPosition.DistanceTo(Self.GetPlayerPosition) >= MELEE_DISTANCE_THRESHOLD then
  begin
    //use the opposite at range combat style if we're not confident in a projectile, or choose at random if we have melee or no prayer active
    case activeProtection of
      ERSPrayer.PROTECT_FROM_MISSILES:  Self.SetTormentedDemonCombatStyle(ERSCombatStyle.MAGIC);
      ERSPrayer.PROTECT_FROM_MAGIC:     Self.SetTormentedDemonCombatStyle(ERSCombatStyle.RANGED);
      else
        if Random(2) then
          Self.SetTormentedDemonCombatStyle(ERSCombatStyle.MAGIC)
        else
          Self.SetTormentedDemonCombatStyle(ERSCombatStyle.RANGED);
    end;
  end else
  begin
    //if active protection is magic, or ranged, then set to melee, if melee
    if activeProtection in [ERSPrayer.PROTECT_FROM_MISSILES, ERSPrayer.PROTECT_FROM_MAGIC] then
    begin
      Self.SetTormentedDemonCombatStyle(ERSCombatStyle.MELEE);
      Exit;
    end;

    //Check for a lower confidence than we're normally looking for before choosing at random.
    if projectileStyleConfidence > PROJECTILE_CONFIDENCE_LO then
    begin
      Self.SetTormentedDemonCombatStyle(detectedProjectileStyle);
      Exit;
    end;

    if Random(2) then
      Self.SetTormentedDemonCombatStyle(ERSCombatStyle.MAGIC)
    else
      Self.SetTormentedDemonCombatStyle(ERSCombatStyle.RANGED);
  end;
end;

procedure TGameStateObserver.Start();
begin
  Self.pHitsplatBuffer.Init(50, SizeOf(TRSHitsplat));
  Self.pPositionBuffer.Init(200, SizeOf(TPoint));
  Self.tdProjectileBuffer.Init(200, SizeOf(ERSCombatStyle));

  Self.pLock := TLock.Create;
  Self.tdLock := TLock.Create;
  Self.TaskManager.Init('game_state', CPUInfo.CoreCount);

  Self.TaskManager.Schedule(@Self.TrackPlayerPosition);
  Self.TaskManager.Schedule(@Self.ReadGameTabs);
  Self.TaskManager.Schedule(@Self.FindTormentedDemon);
  Self.TaskManager.Schedule(@Self.FindTormentedDemonSnare);
  Self.TaskManager.Schedule(@Self.TrackTormentedDemonCombatStyle);
  Self.TaskManager.Schedule(@Self.TrackPlayerHitsplats);

  WriteLn('ReadPlayerPosition: ', ToStr(@Self.TrackPlayerPosition));
  Writeln('FindTormentedDemon: ', ToStr(@Self.FindTormentedDemon));
end;

function TGameState.GetPlayerPosition(): TPoint;
begin
  Self.Observer.pLock.Enter;
  Result := Self.Observer.pPosition;
  Self.Observer.pLock.Leave;
end;

function TGameState.GetInventoryItems(): TRSDiscoveredInventory;
begin
  Self.Observer.pLock.Enter;
  Result := Self.Observer.pInventoryItems.Copy;
  Self.Observer.pLock.Leave;
end;

function TGameState.GetPlayerActivePrayers(): TRSPrayerSet;
begin
  Self.Observer.pLock.Enter;
  Result := Self.Observer.pActivePrayers;
  Self.Observer.pLock.Leave;
end;

function TGameState.IsPlayerSnared(): Boolean;
begin
  Self.Observer.pLock.Enter;
  Result := Self.Observer.tdIsCastingSnare;
  Self.Observer.pLock.Leave;
end;

function TGameState.GetTormentedDemonMSPoints(): TPointArray;
begin
  Self.Observer.tdLock.Enter;
  Result := Self.Observer.tdMainScreenPoints.Copy;
  Self.Observer.tdLock.Leave;
end;

function TGameState.GetTormentedDemonPosition(): TPoint;
begin
  Self.Observer.tdLock.Enter;
  Result := Self.Observer.tdPosition;
  Self.Observer.tdLock.Leave;
end;

function TGameState.GetTormentedDemonCombatStyle(): ERSCombatStyle;
begin
  Self.Observer.tdLock.Enter;
  Result := Self.Observer.tdCombatStyle;
  Self.Observer.tdLock.Leave;
end;

function TGameState.GetTormentedDemonProtectedStyle(): ERSCombatStyle;
begin
  Self.Observer.tdLock.Enter;
  Result := Self.Observer.tdProtectedStyle;
  Self.Observer.tdLock.Leave;
end;

var
  GameState: TGameState;






