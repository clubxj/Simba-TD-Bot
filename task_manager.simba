type
  PThreadPool = ^TThreadPool;

  TThreadPoolWorker = record
    Thread: TThread;
    Pool: PThreadPool;
  end;

  PThreadPoolTask = ^TThreadPoolTask;
  TThreadPoolTask = record
    Runnable: procedure() of object;
    Next: PThreadPoolTask;
  end;

  TThreadPool = record
    Name: String;
    Terminated: Boolean;
    Workers: array of TThreadPoolWorker;
    Tasks: PThreadPoolTask;
    TaskLock: TLock;
  end;

function TThreadPool.NextTask(): PThreadPoolTask;
begin
  Self.TaskLock.Enter;
  Result := Self.Tasks;
  if (Result <> nil) then
  begin
    Self.Tasks := Result^.Next;
    Result^.Next := nil;
  end;
  Self.TaskLock.Leave;
end;

procedure TThreadPoolWorker.Execute();
var
  Task: PThreadPoolTask;
begin
  while not Self.Pool^.Terminated do
  begin
    Task := nil;

    Task := Self.Pool^.NextTask();

    if Self.Pool^.Terminated then
      Break;

    if Task = nil then
    begin
      Sleep(10);
      Continue;
    end;

    try
      Task^.Runnable();
    except
      writeln GetExceptionMessage;
      writeln DumpCallStack;
    end;

    Dispose(Task);
  end;
end;

procedure TThreadPool.Init(name: String; size: Integer);
var
  i: Integer;
begin
  Self.Name := name;
  Self.TaskLock := TLock.Create;

  SetLength(Self.Workers, size);
  for i := 0 to High(Self.Workers) do
  begin
    with Self.Workers[I] do
    begin
      Thread := TThread.Create(@Execute);
      Thread.Name := Format('%s-Worker-%d', [Self.Name, i]);
      Pool := @Self;
    end;
  end;
end;

procedure TThreadPool.Run(runnable: procedure() of object);
var
  newTask, task: PThreadPoolTask;
begin
  New(newTask);
  newTask^.Runnable := @runnable;
  newTask^.Next := nil;

  Self.TaskLock.Enter;
  if Self.Tasks = nil then
  begin
    Self.Tasks := newTask;
  end else
  begin
    task := Self.Tasks;
    while task^.Next <> nil do
      task := task^.Next;

    task^.Next := newTask;
  end;
  Self.TaskLock.Leave;
end;

procedure TThreadPool.Terminate();
var
  i : Integer;
begin
  Self.Terminated := True;
  for i := 0 to High(Self.Workers) do
    with Self.Workers[i].Thread do
    begin
      Terminate;
      WaitForTerminate;
      Free;
    end;
  Self.TaskLock.Free;
end;

type
  TReschedulingTask = record
    ThreadPool: ^TThreadPool;
    Task: procedure() of object;
  end;

procedure TReschedulingTask.Run();
var
  newTask: ^TReschedulingTask;
begin
  if @Self.Task = nil then
    Exit;

  Self.Task();
  Sleep(1);

  // Allocate a fresh task to avoid reuse issues
  New(newTask);
  newTask^.ThreadPool := Self.ThreadPool;
  newTask^.Task := @Self.Task;
  newTask^.ThreadPool^.Run(@newTask^.Run);

  Dispose(Self);
end;

type
  TReschedulingTaskManager = record
    ThreadPool: TThreadPool;
  end;

function timeBeginPeriod(uMilliseconds: UInt32): UInt32; external 'timeBeginPeriod@winmm.dll';
function timeEndPeriod(uMilliseconds: UInt32): UInt32; external 'timeEndPeriod@winmm.dll';

procedure TReschedulingTaskManager.Init(name: String; size: Integer);
begin
  Self.ThreadPool.Init(name, size);
end;

procedure TReschedulingTaskManager.Schedule(Task: procedure() of object);
var
  newTask: ^TReschedulingTask;
begin
  New(newTask);
  newTask^.ThreadPool := @Self.ThreadPool;
  newTask^.Task := @Task;
  Self.ThreadPool.Run(@newTask^.Run);
end;

procedure TReschedulingTaskManager.Terminate();
begin
  Self.ThreadPool.Terminate;
end;

